package main

import (
	"fmt"
)

// ============================================================
// ПОЧЕМУ DEFAULT СРАБАТЫВАЕТ ТОЛЬКО КОГДА КАНАЛ ПУСТ?
// ============================================================

func whyDefaultWorks() {
	fmt.Println("=== ОБЪЯСНЕНИЕ DEFAULT В SELECT ===\n")

	fmt.Println("SELECT работает так:")
	fmt.Println("1. Проверяет ВСЕ case - какие из них ГОТОВЫ выполниться")
	fmt.Println("2. Если есть ХОТЯ БЫ ОДИН готовый case - выбирает его СЛУЧАЙНО")
	fmt.Println("3. Default выполняется ТОЛЬКО если НИ ОДИН case не готов\n")

	fmt.Println("Когда case готов к выполнению?")
	fmt.Println("- case <-ch: готов, если в канале ЕСТЬ данные (можно прочитать)")
	fmt.Println("- case ch<-val: готов, если в канале ЕСТЬ место (можно записать)")
	fmt.Println("- default: готов ВСЕГДА (но выполнится только если остальные не готовы)\n")

	fmt.Println("Пример из задачи:")
	fmt.Println("- Канал ПОЛОН → оба case (<-c и <-c) ГОТОВЫ → default НЕ выполнится")
	fmt.Println("- Канал ПУСТ → оба case (<-c и <-c) НЕ готовы → default выполнится\n")

	// Демонстрация
	ch := make(chan int, 1)

	fmt.Println("Демонстрация 1: канал ПУСТ")
	select {
	case <-ch:
		fmt.Println("  Прочитали (не выполнится)")
	default:
		fmt.Println("  ✓ Default сработал - канал пуст!\n")
	}

	fmt.Println("Демонстрация 2: канал ПОЛОН")
	ch <- 42
	select {
	case <-ch:
		fmt.Println("  ✓ Прочитали - канал был полон!")
	default:
		fmt.Println("  Default (не выполнится)")
	}

	fmt.Println("\n" + "=" + "\n")
}

func task6_0() {

	// Рекурсивный тип: канал, который передаёт сам себя
	type c chan c
	// Создаём буферизованный канал с буфером размером 1
	var ch = make(c, 1)

	// Кладём канал в сам себя (буфер позволяет это сделать)
	ch <- ch

	fmt.Println("=== Пошаговое выполнение ===\n")

	// Начинаем цикл
	for i := 0; i < 1000; i++ {
		fmt.Printf("Итерация %d:\n", i)

		select {
		case <-ch:
			// ПЕРВЫЙ case: просто читаем из канала
			fmt.Printf("  - Выполнился ПЕРВЫЙ case (просто прочитали)\n")
			fmt.Printf("  - Канал теперь ПУСТ\n\n")

		case <-ch:
			// ВТОРОЙ case: читаем из канала И сразу кладём обратно
			fmt.Printf("  - Выполнился ВТОРОЙ case (прочитали и положили обратно)\n")
			ch <- ch
			fmt.Printf("  - Канал снова ПОЛОН\n\n")

		default:
			// DEFAULT: выполнится только если канал пуст
			fmt.Printf("  - Выполнился DEFAULT (канал пуст!)\n")
			fmt.Printf("  - Программа завершается на итерации %d\n", i)
			return
		}
	}
}

// ============================================================
// ЗАДАЧА 1: Что выведет программа?
// ============================================================

func task6_1() {
	fmt.Println("=== ЗАДАЧА 1 ===")
	fmt.Println("Что выведет программа?\n")

	ch := make(chan int, 1)
	ch <- 1

	select {
	case <-ch:
		fmt.Println("case 1")
	case <-ch:
		fmt.Println("case 2")
	default:
		fmt.Println("default")
	}

	fmt.Println("\nОтвет: case 1 ИЛИ case 2 (50/50, оба готовы)")
	fmt.Println("Default НЕ выполнится - есть готовые case\n")
}

// ============================================================
// ЗАДАЧА 2: Что выведет программа?
// ============================================================

func task6_2() {
	fmt.Println("=== ЗАДАЧА 2 ===")
	fmt.Println("Что выведет программа?\n")

	ch := make(chan int)

	select {
	case <-ch:
		fmt.Println("read")
	case ch <- 1:
		fmt.Println("write")
	default:
		fmt.Println("default")
	}

	fmt.Println("\nОтвет: default")
	fmt.Println("Небуферизованный канал пуст, записать нельзя (нет читателя)")
	fmt.Println("Оба case НЕ готовы → default\n")
}

// ============================================================
// ЗАДАЧА 3: Сколько раз выполнится цикл?
// ============================================================

func task6_3() {
	fmt.Println("=== ЗАДАЧА 3 ===")
	fmt.Println("Сколько раз выполнится цикл?\n")

	ch := make(chan int, 1)
	ch <- 1
	count := 0

	for i := 0; i < 10; i++ {
		select {
		case <-ch:
			count++
		default:
			fmt.Printf("Завершилось на итерации %d\n", i)
			goto end
		}
	}
end:
	fmt.Printf("\nОтвет: 1 раз")
	fmt.Println("\nИтерация 0: прочитали → канал пуст")
	fmt.Println("Итерация 1: default → конец\n")
}

// ============================================================
// ЗАДАЧА 4: Что выведет программа?
// ============================================================

func task6_4() {
	fmt.Println("=== ЗАДАЧА 4 ===")
	fmt.Println("Что выведет программа?\n")

	ch := make(chan int, 2)
	ch <- 1
	ch <- 2

	for i := 0; i < 5; i++ {
		select {
		case v := <-ch:
			fmt.Printf("Прочитали: %d\n", v)
		default:
			fmt.Printf("Default на итерации %d\n", i)
			goto end4
		}
	}
end4:
	fmt.Println("\nОтвет: Прочитали 1, Прочитали 2, Default на итерации 2")
	fmt.Println("Буфер размером 2 → 2 чтения → канал пуст → default\n")
}

// ============================================================
// ЗАДАЧА 5: Рекурсивный канал с большим буфером
// ============================================================

func task6_5() {
	fmt.Println("=== ЗАДАЧА 5 ===")
	fmt.Println("Что выведет программа?\n")

	type c chan c
	ch := make(c, 2)
	ch <- ch
	ch <- ch

	for i := 0; i < 10; i++ {
		select {
		case <-ch:
			// Просто читаем
		default:
			fmt.Printf("Завершилось на итерации %d\n", i)
			goto end5
		}
	}
end5:
	fmt.Println("\nОтвет: итерация 2")
	fmt.Println("В канале 2 элемента → 2 чтения → канал пуст → default\n")
}

// ============================================================
// ЗАДАЧА 6: Два канала
// ============================================================

func task6_6() {
	fmt.Println("=== ЗАДАЧА 6 ===")
	fmt.Println("Что выведет программа?\n")

	ch1 := make(chan int, 1)
	ch2 := make(chan int, 1)
	ch1 <- 1

	select {
	case <-ch1:
		fmt.Println("ch1")
	case <-ch2:
		fmt.Println("ch2")
	default:
		fmt.Println("default")
	}

	fmt.Println("\nОтвет: ch1")
	fmt.Println("Только ch1 готов к чтению, ch2 пуст")
	fmt.Println("Default не выполнится - есть готовый case\n")
}

// ============================================================
// ЗАДАЧА 7: Запись в полный канал
// ============================================================

func task6_7() {
	fmt.Println("=== ЗАДАЧА 7 ===")
	fmt.Println("Что выведет программа?\n")

	ch := make(chan int, 1)
	ch <- 1

	select {
	case ch <- 2:
		fmt.Println("Записали")
	default:
		fmt.Println("Не записали - канал полон")
	}

	fmt.Println("\nОтвет: Не записали - канал полон")
	fmt.Println("Канал полон (1/1) → case записи НЕ готов → default\n")
}

// ============================================================
// ЗАДАЧА 8: Чтение и запись одновременно
// ============================================================

func task6_8() {
	fmt.Println("=== ЗАДАЧА 8 ===")
	fmt.Println("Что выведет программа?\n")

	ch := make(chan int, 1)
	ch <- 1

	select {
	case <-ch:
		fmt.Println("Прочитали")
	case ch <- 2:
		fmt.Println("Записали")
	default:
		fmt.Println("default")
	}

	fmt.Println("\nОтвет: Прочитали ИЛИ default (но НЕ записали)")
	fmt.Println("Канал полон: чтение готово, запись НЕ готова")
	fmt.Println("Go выберет между чтением и default случайно\n")

	fmt.Println("Стоп! Это НЕПРАВИЛЬНО!")
	fmt.Println("Правильный ответ: Прочитали (100%)")
	fmt.Println("Канал полон → case чтения ГОТОВ")
	fmt.Println("Если есть хотя бы 1 готовый case → default НЕ выполнится!\n")
}

// ============================================================
// ЗАДАЧА 9: Закрытый канал
// ============================================================

func task6_9() {
	fmt.Println("=== ЗАДАЧА 9 ===")
	fmt.Println("Что выведет программа?\n")

	ch := make(chan int)
	close(ch)

	for i := 0; i < 3; i++ {
		select {
		case v := <-ch:
			fmt.Printf("Итерация %d: прочитали %d\n", i, v)
		default:
			fmt.Printf("Итерация %d: default\n", i)
			goto end9
		}
	}
end9:
	fmt.Println("\nОтвет: Прочитали 0, Прочитали 0, Прочитали 0")
	fmt.Println("Закрытый канал ВСЕГДА готов к чтению!")
	fmt.Println("Возвращает zero value (0 для int)")
	fmt.Println("Default НЕ выполнится никогда\n")
}

// ============================================================
// ЗАДАЧА 10: Сложная рекурсивная задача
// ============================================================

func task6_10() {
	fmt.Println("=== ЗАДАЧА 10 ===")
	fmt.Println("Что выведет программа? (самая сложная)\n")

	type c chan c
	ch := make(c, 1)
	ch <- ch

	for i := 0; i < 100; i++ {
		select {
		case <-ch:
			// Читаем, канал пустеет
		case <-ch:
			// Читаем и сразу пишем обратно
			ch <- ch
		case <-ch:
			// Ещё один case чтения
			ch <- ch
			ch <- ch // Пытаемся записать 2 раза!
		default:
			fmt.Printf("Завершилось на итерации %d\n", i)
			goto end10
		}
	}
end10:
	fmt.Println("\nОтвет: Завершится на ранней итерации")
	fmt.Println("3 case - все случайно выбираются")
	fmt.Println("Case 1: 1/3 шанс опустошить канал")
	fmt.Println("Case 2: 1/3 шанс оставить полным")
	fmt.Println("Case 3: 1/3 шанс - ПАНИКА! (записать 2 раз в буфер 1)")
	fmt.Println("\nНа самом деле case 3 вызовет панику при попытке")
	fmt.Println("записать второй раз в полный канал!\n")
}

// ============================================================
// БОНУСНАЯ ЗАДАЧА: Демонстрация недетерминированности
// ============================================================

func bonusTask() {
	fmt.Println("=== БОНУС: Недетерминированность ===")
	fmt.Println("Запустим одну и ту же программу 10 раз:\n")

	results := make(map[int]int)

	for run := 0; run < 10; run++ {
		type c chan c
		ch := make(c, 1)
		ch <- ch

		for i := 0; i < 1000; i++ {
			select {
			case <-ch:
			case <-ch:
				ch <- ch
			default:
				results[i]++
				fmt.Printf("Запуск %2d: завершилось на итерации %d\n", run+1, i)
				goto next
			}
		}
	next:
	}

	fmt.Println("\n=== Статистика завершений ===")
	for i := 0; i < 20; i++ {
		if count := results[i]; count > 0 {
			fmt.Printf("Итерация %2d: %d раз(а)\n", i, count)
		}
	}
	fmt.Println()
}

// ============================================================
// MAIN
// ============================================================

func main() {
	whyDefaultWorks()

	task6_0()
	task6_1()
	task6_2()
	task6_3()
	task6_4()
	task6_5()
	task6_6()
	task6_7()
	task6_8()
	task6_9()

	fmt.Println("=== ЗАДАЧА 10 - БУДЕТ ПАНИКА! ===")
	fmt.Println("Раскомментируйте task10() чтобы увидеть панику\n")
	// task10() // Осторожно - паника!

	bonusTask()

	fmt.Println("\n=== КЛЮЧЕВЫЕ ВЫВОДЫ ===")
	fmt.Println("1. Default выполняется ТОЛЬКО если НИ ОДИН case не готов")
	fmt.Println("2. Чтение готово когда: канал НЕ пуст ИЛИ канал закрыт")
	fmt.Println("3. Запись готова когда: в канале есть место")
	fmt.Println("4. Select выбирает готовый case СЛУЧАЙНО")
	fmt.Println("5. Закрытый канал ВСЕГДА готов к чтению (возвращает zero value)")
	fmt.Println()
}
