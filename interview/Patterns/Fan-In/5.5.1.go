package main

import "sync"

//задание 5.5.1: Реализуйте функцию fanin, которая принимает на вход несколько каналов и
//возвращает один канал, по которому будут передаваться все значения из
//входных каналов.
func fanin(chans ...<-chan int) <-chan int {
	result := make(chan int)
	wg := sync.WaitGroup{}
	go func() {
		for _, ch := range chans {
			wg.Add(1)
			go func(ch <-chan int) {
				defer wg.Done()
				for val := range ch {
					result <- val
				}
			}(ch)
		}
		wg.Wait()
		close(result)
	}()
	return result
}

/*
Ниже — **полный построчный, формальный и технически точный разбор** реализации fan-in, включая объяснение контекста Go memory model, правил работы с каналами и поведения WaitGroup.

---

# Разбор кода по строкам

```go
func fanin(chans ...<-chan int) <-chan int {
```

**1. Объявление функции**

* `fanin` принимает **произвольное количество входящих каналов**: `chans ...<-chan int`.
* Тип `"<-chan int"` означает **канал только для чтения**. Функция не может в них отправлять данные.
* Возвращает один **объединённый выходной канал** (`<-chan int`), из которого потребитель будет читать объединённый поток значений.

---

```go
    result := make(chan int)
```

**2. Создаём результирующий канал**

* Это **двунаправленный канал** (но функция возвращает его как read-only).
* В него будут попадать значения из всех входных каналов.

---

```go
    wg := sync.WaitGroup{}
```

**3. Создаем WaitGroup**

* WaitGroup используется для **синхронизации завершения всех горутин**, читающих входные каналы.
* Функция не должна закрыть `result` раньше, чем все источники закончатся.

---

```go
    go func() {
```

**4. Старт общей управляющей горутины**
Эта горутина отвечает за:

* запуск рабочих горутин для каждого канала;
* ожидание их завершения;
* закрытие результирующего канала.

Это позволяет **не блокировать вызов `fanin()`** — он возвращает `result` сразу.

---

```go
        for _, ch := range chans {
```

**5. Итерируемся по входным каналам**
`ch` — это конкретный входной канал для чтения.

---

```go
            wg.Add(1)
```

**6. Увеличиваем счетчик WaitGroup**

* Каждая входная горутина должна вызвать `Done()`
* Это гарантирует, что **мы закроем result только тогда, когда все входные каналы прочитаны до конца**.

---

```go
            go func() {
                defer wg.Done()
                for val := range ch {
                    result <- val
                }
            }()
```

**7. Запускаем worker-горутины для каждого входного канала**

Разбор построчно:

### `go func() {`

Старт горутины, обслуживающей один входной канал.

### `defer wg.Done()`

Гарантирует уменьшение счетчика после завершения горутины.

### `for val := range ch`

* Чтение из входного канала до его закрытия.
* Как только `ch` закрыт — этот цикл завершается.

### `result <- val`

* Отправляем значение в общий канал.
* Если `result` не читают — эта строка может заблокировать worker.
* Fan-in предполагает, что потребитель читает достаточно быстро.

**Важно:**
Анонимная функция не принимает аргумент `ch`, что может привести к **замыканию и гонкам**. То есть `ch` внутри горутины — переменная внешнего цикла.
Корректный вариант — делать:

```go
for _, ch := range chans {
    wg.Add(1)
    go func(ch <-chan int) {
        defer wg.Done()
        for val := range ch {
            result <- val
        }
    }(ch)
}
```

---

```go
        }
```

**8. Завершение цикла по каналам**

---

```go
        wg.Wait()
```

**9. Ожидаем завершения всех горутин**

* WaitGroup заблокирует выполнение **до тех пор**, пока все worker-горутины не выйдут из цикла `range ch`.

---

```go
        close(result)
```

**10. После того как все входные каналы закрыты — закрываем result**
Это важно: потребитель получает EOF (`range result` завершится).

**Если закрыть раньше — будет паника**, поскольку worker попробует отправить в закрытый канал.

---

```go
    }()
```

**11. Закрытие управляющей горутины**

---

```go
    return result
}
```

**12. Возврат объединённого канала**

* Управляющая горутина работает в фоне.
* Потребитель может начинать читать сразу.

---

# Итоговая семантическая схема

```
fanin
 ├─ создает общий канал result
 ├─ создает WaitGroup
 ├─ запускает управляющую горутину
 │    ├─ для каждого входного канала запускает worker
 │    ├─ ждет окончания всех workers (wg.Wait)
 │    └─ закрывает result
 └─ возвращает result
```

Worker-горутина:

```
range ch {
    result <- val
}
wg.Done()
```

---

# Возможные проблемы и улучшения

### 1. Захват переменной цикла (bug)

В оригинале:

```go
for _, ch := range chans {
    go func() {
        for val := range ch {
```

`ch` замкнется как ссылка на переменную цикла → **все goroutines могут читать один и тот же последний канал**.

Исправление:

```go
for _, ch := range chans {
    go func(ch <-chan int) {
        for val := range ch {
            result <- val
        }
    }(ch)
}
```

---

### 2. Потенциальная блокировка result

Если потребитель не успевает читать, fan-in зависнет на:

```go
result <- val
```

### 3. Нежелание использовать буфер

Иногда полезно:

```go
result := make(chan int, 1024)
```

---

# Итог

Это корректная реализация паттерна **fan-in**, позволяющая:

* читать из N входных каналов конкуррентно;
* отправлять всё в один выходной канал;
* корректно закрывать выходной канал после завершения всех входов.

Если нужно — могу написать:

* версию с контекстом (context.Context)
* неблокирующий вариант
* fan-in с таймаутами
* fan-in с сохранением порядка сообщений
* версию с worker pool

Скажи, продолжать?
*/
